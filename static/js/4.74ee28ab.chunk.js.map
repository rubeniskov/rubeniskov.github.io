{"version":3,"sources":["../packages/sandbox/glsl/get.js","../packages/sandbox/glsl/setup.js","../../glslify-deps/depper.js","../../glslify-deps/utils.js","../packages/sandbox/glsl/utils.js","../packages/sandbox/glsl/glsl-resolve-browser.js","../packages/sandbox/glsl/glslify-deps.js","../packages/sandbox/glsl/glslify.js","../packages/sandbox/glsl/index.js"],"names":["get","url","opts","cb","type","async","xhr","global","XMLHttpRequest","ActiveXObject","e","Error","makeRequest","open","setRequestHeader","send","status","responseText","statusText","onload","onerror","sync","getShaderError","gl","source","vertext","shader","createShader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","setup","canvas","onError","attributes","uniforms","restOps","regl","createRegl","resizer","canvasFit","_gl","glsl","glslify","fragment","fn","err","frag","defaults","vert","drawTriangle","position","buffer","time","prop","resolution","count","frame","clear","color","depth","drawingBufferWidth","drawingBufferHeight","draw","addEventListener","removeEventListener","detachResize","destroy","EventEmitter","require","map","genInlineName","getImportName","extractPreprocessors","asyncify","Depper","constructor","_inlineSource","_inlineName","_async","_i","_deps","_cache","_transforms","_globalTransforms","readFile","_readFile","resolve","transformRequire","_transformRequireAsync","filename","done","this","add","self","exports","imports","dep","_addDep","resolveOpts","Object","assign","deps","process","_","next","getTransformsForFile","src","transforms","emit","applyTransforms","updated","_resolveImports","console","warn","transform","name","list","post","push","tr","selectTransform","resolved","forEach","i","length","file","extra","id","entry","result","concat","resolveTransform","idx","parallel","importName","imp","module","tokenize","path","glslifyPreprocessor","data","test","glslifyExport","exec","glslifyImport","apply","args","mix","mixed","getTransformsFromPkg","pkgJson","JSON","parse","Array","isArray","key","opt","split","shift","trim","replace","tokens","token","exp","Math","random","cacheWrap","read","cache","nextTick","content","parseFiles","files","keys","reduce","newCache","fns","initialState","state","cursor","pop","error","fallback","creator","createLocalStorageCache","set","value","remove","prefix","localStorage","setItem","getItem","removeItem","check","wrapCache","log","cached","defaultExts","formatUrl","base","URL","join","matchExt","pkgName","exts","RegExp","parseOptions","urlPath","message","DepperBrowser","glslResolve","depper","glslifyBundle","glslifyDeps","inline","String","styled","className","useState","setError","canvasRef","useRef","drawRef","useLayoutEffect","current","_jsxs","children","_jsx","ref","withConfig","displayName","componentId"],"mappings":"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","file":"static/js/4.74ee28ab.chunk.js","sourcesContent":["const makeRequest = () => {\n  if (global.XMLHttpRequest) {\n    // Mozilla, Safari, ...\n    return new global.XMLHttpRequest();\n  } else if (global.ActiveXObject) {\n    // IE\n    try {\n      return new global.ActiveXObject(\"Msxml2.XMLHTTP\");\n    } catch (e) {\n      try {\n        return new global.ActiveXObject(\"Microsoft.XMLHTTP\");\n      } catch (e) {}\n    }\n  }\n\n  throw new Error(\"Giving up :( Cannot create an XMLHTTP instance\");\n};\n\nconst get = (url, opts, cb) => {\n  if (typeof opts === \"function\") {\n    cb = opts;\n    opts = {};\n  }\n\n  const {\n    type = \"GET\",\n    async = !!cb\n  } = { ...opts\n  };\n  let xhr = makeRequest();\n  xhr.open(type, url, async);\n  xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n\n  if (!async) {\n    xhr.send();\n\n    if (xhr.status < 400) {\n      return xhr.responseText;\n    } else {\n      throw new Error(`${xhr.status} - ${xhr.statusText}`);\n    }\n  }\n\n  xhr.onload = () => {\n    if (xhr.status < 400) {\n      cb(null, xhr.responseText);\n    } else {\n      cb(new Error(`${xhr.status} - ${xhr.statusText}`));\n    }\n  };\n\n  xhr.onerror = () => cb(new Error(`${xhr.status} - ${xhr.statusText}`));\n\n  xhr.send();\n};\n\nget.sync = (url, opts) => get(url, {\n  async: false,\n  ...opts\n});\n\nexport default get;","import canvasFit from \"canvas-fit\";\nimport createRegl from \"regl/dist/regl.unchecked\"; // import createRegl from \"regl/dist/regl.js\";\n\nimport glslify from \"./glslify\";\nimport * as defaults from \"./defaults\";\n\nconst attachResize = fn => {\n  if (global.addEventListener) {\n    global.addEventListener(\"resize\", fn, false);\n  }\n};\n\nconst detachResize = fn => {\n  if (global.removeEventListener) {\n    global.removeEventListener(\"resize\", fn);\n  }\n};\n\nconst getShaderError = (gl, source, vertext) => {\n  var shader = gl.createShader(vertext ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader); // Check for any compilation error\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    return gl.getShaderInfoLog(shader);\n  }\n\n  return null;\n};\n\nconst setup = (canvas, opts) => {\n  const {\n    onError,\n    attributes,\n    uniforms,\n    ...restOps\n  } = { ...opts\n  };\n  const regl = createRegl(canvas);\n  const resizer = canvasFit(canvas);\n  const gl = regl._gl;\n  const glsl = glslify(opts);\n  return fragment => {\n    const draw = ({\n      frag = defaults.fragment,\n      vert = defaults.vertex\n    } = {}) => {\n      const err = getShaderError(gl, frag);\n\n      if (err && onError) {\n        return onError(new Error(err));\n      }\n\n      const drawTriangle = regl({ ...restOps,\n        frag,\n        vert,\n        attributes: {\n          position: regl.buffer([[-1, -1], [-1, 4], [4, -1] // [-2, -2],\n          // [4, -2],\n          // [4, 4],\n          ]),\n          ...attributes\n        },\n        uniforms: {\n          time: regl.prop(\"time\"),\n          resolution: regl.prop(\"resolution\"),\n          ...uniforms\n        },\n        count: 3\n      });\n      regl.frame(({\n        time\n      }) => {\n        regl.clear({\n          color: [0, 0, 0, 0],\n          depth: 1\n        });\n        drawTriangle({\n          time,\n          resolution: [gl.drawingBufferWidth, gl.drawingBufferHeight]\n        });\n      });\n    };\n\n    glsl(fragment, (err, frag) => {\n      if (err) {\n        if (onError) {\n          return onError(err);\n        }\n\n        throw err;\n      }\n\n      draw({\n        frag\n      });\n    });\n    attachResize(resizer);\n    return () => {\n      detachResize(resizer);\n      regl.destroy();\n    };\n  };\n};\n\nexport default setup;","// @ts-check\n\n/** @typedef {import('glsl-resolve')} GlslResolve */\nconst EventEmitter = require('events').EventEmitter;\n\nconst map = require('map-limit');\n\nconst {\n  genInlineName,\n  getImportName,\n  extractPreprocessors,\n  asyncify\n} = require('./utils.js');\n/**\n * @callback GlslTransformSync\n * @param {String} filename The absolute path of the file you're transforming.\n * @param {String} src The shader source you'd like to transform.\n * @param {Object} opts The transform options.\n * @returns {String} transformed shader\n */\n\n/**\n * @callback GlslTransformAsync\n * @param {String} filename The absolute path of the file you're transforming.\n * @param {String} src The shader source you'd like to transform.\n * @param {Object} opts The transform options.\n * @param {(err: Error, result: String) => any} [cb] callback with the transformed shader\n */\n\n/**\n * @typedef {GlslTransformSync|GlslTransformAsync} GlslTransform\n */\n\n/**\n * @callback TransformRequireSync\n * @param {String|GlslTransform} transform\n * @param {Object} opts\n * @returns {GlslTransform}\n */\n\n/**\n * @callback TransformRequireAsync\n * @param {String|GlslTransform} transform\n * @param {Object} opts\n * @param {(err: Error, transform: GlslTransform) => any} [cb]\n */\n\n/**\n * @typedef {TransformRequireSync|TransformRequireAsync} TransformRequire\n */\n\n/**\n * @typedef {Object} TransformDefinition\n * @prop {string|GlslTransform} tr\n * @prop {string} name\n * @prop {any} opts\n */\n\n/**\n * @typedef {Object} TransformResolved\n * @prop {GlslTransform} tr\n * @prop {string} name\n * @prop {any} opts\n */\n\n/**\n * @typedef {Object} DepperOptions\n * @prop {Boolean} [async] Defines the mechanism flow resolution.\n * @prop {Function} [readFile] pass in a custom function reading files.\n * @prop {GlslResolve} [resolve] pass in a custom function for resolving require calls. It has the same signature as glsl-resolve.\n * @prop {Object<string, string>} [files] a filename/source object mapping of files to prepopulate the file cache with. Useful for overriding.\n * @prop {TransformRequireAsync|TransformRequireSync} [transformRequire] pass in a custom function for resolving non function transforms.\n */\n\n/**\n * @typedef {Object} DepperGraph\n * @prop {Number} id\n * @prop {Object<string, number>} deps\n * @prop {String} file\n * @prop {String} source\n * @prop {Boolean} entry\n */\n\n/**\n * Creates a new instance of glslify-deps. Generally, you'll\n * want to use one instance per bundle.\n *\n * note: this is an interface to be extended with a top class\n * @abstract\n */\n\n\nclass Depper extends EventEmitter {\n  /**\n   * @param {DepperOptions} [opts] options\n   */\n  constructor(opts) {\n    super();\n\n    if (this.constructor === Depper) {\n      throw new Error(\"Depper classes can't be instantiated.\");\n    }\n\n    opts = opts || {};\n    this._inlineSource = '';\n    this._inlineName = genInlineName();\n    this._async = opts.async || false;\n    this._i = 0;\n    this._deps = [];\n    this._cache = {};\n    /** @type {TransformDefinition[]} */\n\n    this._transforms = [];\n    /** @type {TransformDefinition[]} */\n\n    this._globalTransforms = [];\n\n    if (!opts.readFile) {\n      throw new Error('glslify-deps: readFile must be defined');\n    }\n\n    this._readFile = opts.readFile;\n\n    if (!opts.resolve) {\n      throw new Error('glslify-deps: resolve must be defined');\n    }\n\n    this.resolve = opts.resolve;\n\n    if (!opts.transformRequire) {\n      throw new Error('glslify-deps: transformRequire must be defined');\n    }\n\n    this.transformRequire = opts.transformRequire; // @ts-ignore\n\n    this._transformRequireAsync = !!opts.transformRequire.sync;\n\n    if (!this._async && this._transformRequireAsync) {\n      throw new Error('glslify-deps: transformRequire async detected \\n when sync context, please ensure your resolver is even with the context');\n    }\n  }\n  /**\n   * Adds a new inline file to the dependency graph, where source is the GLSL source\n   * to include and filename is the identifier of the source\n   * @param {string} source\n   * @param {string} filename\n   * @param {(err: Error, deps: DepperGraph[]) => any} [done]\n   * @returns {DepperGraph[]}\n   */\n\n\n  inline(source, filename, done) {\n    this._inlineSource = source;\n    return this.add(filename || this._inlineName, done);\n  }\n  /**\n   * Adds a shader file to the graph, including its dependencies\n   * which are resolved in this step. Transforms are also applied\n   * in the process too, as they may potentially add or remove dependent\n   * modules.\n   *\n   * @param {String} filename The absolute path of this file.\n   * @param {Object} [opts] The options will be pased to _resolveImports function.\n   * @param {(err: Error, deps?: DepperGraph[]) => any} [done]\n   *\n   * If async is defined then `done` callback will be called when the entire graph has been\n   * resolved, and will include an array of dependencies discovered\n   * so far as its second argument.\n   *\n   * If sync returns an array of dependencies discovered so far as its second argument.\n   */\n\n\n  add(filename, opts, done) {\n    if (typeof opts === 'function') {\n      done = opts;\n      opts = {};\n    }\n\n    const self = this;\n    const exports = [];\n    const imports = [];\n\n    const dep = this._addDep(filename);\n\n    const resolveOpts = Object.assign({\n      deps: dep.deps\n    }, opts);\n    const process = asyncify((_, next) => self.readFile(filename, next), (_, next) => self.getTransformsForFile(filename, next), ([src, transforms], next) => {\n      // @ts-ignore\n      self.emit('file', filename);\n      return self.applyTransforms(filename, src, transforms, next);\n    }, ([,, updated], next) => {\n      extractPreprocessors(dep.source = updated, imports, exports);\n      return self._resolveImports(imports, resolveOpts, next);\n    }, (_, next) => {\n      if (next) {\n        next(null, self._deps);\n      }\n    });\n\n    if (this._async) {\n      process(done || (() => {\n        console.warn('glslify-deps: depper.add() has not a callback defined using async flow');\n      }));\n      return dep;\n    } else {\n      process();\n      return this._deps;\n    }\n  }\n  /**\n   * Dummy internal function for resolve transforms for a file\n   * @param {String} filename The absolute path of the file in question.\n   * @param {(err: Error, transforms?: TransformResolved[]) => any} [done] Applies when async true\n   * @returns {TransformResolved[]} List of transform for a file\n   */\n\n\n  getTransformsForFile(filename, done) {\n    if (done) {\n      done(null, []);\n    }\n\n    console.warn('glslify-deps: depper.getTransformsForFile() not yet implemented');\n    return [];\n  }\n  /**\n   * Adds a transform to use on your local dependencies.\n   * Note that this should be used before calling `add`.\n   *\n   * Transforms are handled using a different API to browserify, e.g.:\n   *\n   * ``` js\n   * module.exports = function transform(filename, src, opts, done) {\n   *   done(null, src.toUpperCase())\n   * }\n   * ```\n   *\n   * Where `filename` is the absolute file path, `src` is the shader source\n   * as a string, `opts` is an options object for configuration, and `done`\n   * is a callback which takes the transformed shader source.\n   *\n   * @param {String|GlslTransform} transform\n   * @param {Object} [opts]\n   * @param {Boolean} [opts.global] adds transform to global scope\n   * @param {Boolean} [opts.post]\n   */\n\n\n  transform(transform, opts) {\n    const name = typeof transform === 'string' ? transform : null;\n    const list = opts && opts.global ? this._globalTransforms : this._transforms; // post transforms are ignored by glslify-deps, to be handled\n    // by glslify after the file has been bundled.\n\n    if (opts && opts.post) return this;\n    list.push({\n      tr: transform,\n      opts: opts,\n      name: name\n    });\n    return this;\n  }\n  /**\n   * Resolves a transform.\n   * Works for both contexts async and sync\n   * Functions are retained as-is.\n   * Strings are resolved using the transformRequire option\n   *\n   *\n   * @param {String|GlslTransform} transform\n   * @param {Object} [opts] The options will be pased to transformRequire function.\n   * @param {(err: Error, transform?: GlslTransform) => any} [done] Applies if is defined\n   * @return {Function}\n   */\n\n\n  resolveTransform(transform, opts, done) {\n    if (typeof opts === 'function') {\n      done = opts;\n      opts = {};\n    }\n\n    if (typeof transform === 'function') {\n      if (done) done(null, transform);\n      return transform;\n    }\n\n    const selectTransform = tr => {\n      if (this._async) return tr;\n\n      if (!tr || typeof tr.sync !== 'function') {\n        const err = new Error('transform ' + transform + ' does not provide a' + ' synchronous interface');\n\n        if (done) {\n          done(err);\n          return null;\n        } else {\n          throw err;\n        }\n      }\n\n      return tr.sync;\n    };\n\n    if (this._transformRequireAsync) {\n      this.transformRequire(transform, opts, (err, resolved) => {\n        if (err) return done(err);\n        return done(null, selectTransform(resolved));\n      });\n    } else {\n      const tr = selectTransform(this.transformRequire(transform, opts));\n      if (tr && done) done(null, tr);\n      return tr;\n    }\n  }\n  /**\n   * Applies a transform to a string.\n   *\n   * Note that transforms here are passed in differently to other methods:\n   * - `tr.tr` should point to the transform function.\n   * - `tr.opts` should contain the options for the transform, if applicable.\n   *\n   * @param {String} filename The absolute path of the file you're transforming.\n   * @param {String} src The shader source you'd like to transform.\n   * @param {TransformResolved[]} transforms The transforms you'd like to apply.\n   * @param {(err: Error, result?: string) => any} [done] Applies when async true\n   */\n\n\n  applyTransforms(filename, src, transforms, done) {\n    if (this._async) {\n      let i = 0;\n\n      const next = (err, updated) => {\n        if (err) return done(err);\n        if (i >= transforms.length) return done(null, updated);\n        const tr = transforms[i++];\n        let opts = tr.opts;\n        if (!opts || typeof opts !== 'object') opts = {};\n        tr.tr(filename, updated + '', tr.opts, next);\n      };\n\n      next(null, src);\n    } else {\n      transforms.forEach(tr => {\n        let opts = tr.opts;\n        if (!opts || typeof opts !== 'object') opts = {};\n        src = tr.tr(filename, src + '', tr.opts);\n      });\n      return src;\n    }\n  }\n  /**\n   * Internal method to add dependencies\n   * @param {object} [extra]\n   */\n\n\n  _addDep(file, extra) {\n    const dep = Object.assign({\n      id: this._i++,\n      file: file,\n      deps: {},\n      source: null,\n      entry: this._i === 1\n    }, extra);\n\n    this._deps.push(dep);\n\n    return dep;\n  }\n  /**\n   * Internal method to register transforms\n   * @param {TransformDefinition[]} transforms\n   * @param {(err: Error, resolved?: TransformResolved[]) => any} [cb]\n   * @returns {TransformResolved[]}\n   */\n\n\n  _register(transforms, cb) {\n    /** @type {TransformResolved[]} */\n    // @ts-ignore\n    const result = transforms.concat(this._globalTransforms); // map acts as synchronous if the iterator is always in\n    // the main thread so is compatible with resolveTransform\n\n    map(result, 1, (tr, next) => {\n      this.resolveTransform(tr.tr, next);\n    }, (err, resolved) => {\n      if (err) {\n        if (cb) return cb(err);\n        throw err;\n      }\n\n      result.forEach((tr, idx) => {\n        tr.tr = resolved[idx];\n      });\n      if (cb) cb(null, result);\n    });\n    return result;\n  }\n  /**\n   * Internal async method to retrieve dependencies\n   * resolving imports using the internal cache\n   *\n   * @param {string[]} imports\n   * @param {object} [opts] The options will be pased to resolve function.\n   * @param {object} [opts.deps] Existing dependencies\n   * @param {number} [opts.parallel=10] Parallel threads when async\n   * @param {(err: Error) => any} [done]\n   * @return {object} Resolved dependencies\n   */\n\n\n  _resolveImports(imports, opts, done) {\n    if (typeof opts === 'function') {\n      done = opts;\n      opts = {};\n    }\n\n    const deps = opts && opts.deps || {};\n    const parallel = opts && opts.parallel || 10;\n    const process = asyncify(([importName], next) => this.resolve(importName, opts, next), ([importName, resolved], next) => {\n      // console.log(this._cache)\n      // if (this._cache[resolved]) {\n      //   deps[importName] = this._cache[resolved].id\n      //   return next && next()\n      // }\n      if (next) {\n        this._cache[resolved] = this.add(resolved, err => {\n          if (err) return next(err);\n          deps[importName] = this._cache[resolved].id;\n          next();\n        });\n      } else {\n        const idx = this._i;\n        this._cache[resolved] = this.add(resolved)[idx];\n        deps[importName] = this._cache[resolved].id;\n      }\n    });\n\n    if (this._async) {\n      map(imports, parallel, (imp, next) => {\n        process([getImportName(imp)], next);\n      }, done);\n    } else {\n      imports.forEach(imp => {\n        process([getImportName(imp)]);\n      });\n    }\n\n    return deps;\n  }\n\n  readFile(filename, done) {\n    if (filename !== this._inlineName) {\n      return this._readFile(filename, done);\n    }\n\n    if (this._async) {\n      return done(null, this._inlineSource);\n    }\n\n    return this._inlineSource;\n  }\n\n}\n\nmodule.exports = Depper;","// @ts-check\nconst tokenize = require('glsl-tokenizer/string');\n\nconst path = require('path');\n\nconst glslifyPreprocessor = data => {\n  return /#pragma glslify:/.test(data);\n};\n\nconst glslifyExport = data => {\n  return /#pragma glslify:\\s*export\\(([^)]+)\\)/.exec(data);\n};\n\nconst glslifyImport = data => {\n  return /#pragma glslify:\\s*([^=\\s]+)\\s*=\\s*require\\(([^)]+)\\)/.exec(data);\n};\n\nconst genInlineName = () => {\n  return '__INLINE__' + Math.random();\n};\n/**\n * Gets glslify transform from given package.json\n *\n * @param {object|string} pkgJson package.json string data or json\n * @returns {({tr: string, name: string, opts: object})[]}\n */\n\n\nconst getTransformsFromPkg = pkgJson => {\n  if (typeof pkgJson === 'string') {\n    pkgJson = JSON.parse(pkgJson);\n  }\n\n  const transforms = pkgJson.glslify && pkgJson.glslify.transform || [];\n  return transforms.map(tr => {\n    const transform = Array.isArray(tr) ? tr : [tr, {}];\n    const key = transform[0];\n    const opt = transform[1];\n\n    if (opt) {\n      delete opt.global;\n      delete opt.post;\n    }\n\n    return {\n      tr: key,\n      opts: opt,\n      name: key\n    };\n  });\n};\n/**\n * Extracts preprocessors copying the imports and exports\n * into respective parameters\n * @param {string} source\n * @param {string[]} imports\n * @param {string[]} exports\n */\n\n\nconst extractPreprocessors = (source, imports, exports) => {\n  const tokens = tokenize(source);\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.type !== 'preprocessor') continue;\n    const data = token.data;\n    if (!glslifyPreprocessor(data)) continue;\n    const exp = glslifyExport(data);\n    const imp = glslifyImport(data);\n    if (exp) exports.push(exp[1]);\n    if (imp) imports.push(imp[2]);\n  }\n};\n\nconst getImportName = imp => {\n  return imp.split(/\\s*,\\s*/).shift().trim().replace(/^'|'$/g, '').replace(/^\"|\"$/g, '');\n};\n/** Fast apply */\n\n\nconst apply = (fn, args) => {\n  switch (args.length) {\n    case 1:\n      return fn(args[0]);\n\n    case 2:\n      return fn(args[0], args[1]);\n\n    case 3:\n      return fn(args[0], args[1], args[2]);\n\n    case 4:\n      return fn(args[0], args[1], args[2], args[3]);\n\n    default:\n      return fn.apply(null, args);\n  }\n};\n/**\n * Takes an sync and async functions and return a function which detects if the last argument\n * is a callback in order to select which flow to use\n * @param {function} sync\n * @param {function} async\n * @returns {(...args, done) => any}\n */\n\n\nconst mix = (sync, async) => {\n  const mixed = (...args) => {\n    if (typeof args[args.length - 1] === 'function') {\n      if (!async) {\n        throw Error('There\\'s no async function available');\n      }\n\n      apply(async, args);\n    }\n\n    if (!sync) {\n      throw Error('There\\'s no sync function available');\n    }\n\n    return apply(sync, args);\n  };\n\n  mixed.sync = sync;\n  mixed.async = async;\n  return mixed;\n};\n/**\n * Allows reuse sync/async logics detecting if done is defined to select which strategy to use.\n * Arguments must be functions, if sync is detected then takes the returned value,\n * otherwise when async next will be defined and will take the result from there\n *\n * @param {...(prevState: any[], next?: (err?: Error, result?: any) => void) => void} fns\n * @returns {((initialState?: any[], done?: (err: Error, state?: any[]) => any) => void[])&((done?: (err: Error, state?: any[]) => any) => any[])}\n * @example\n *\n * const process = asyncify(\n *   ([foo], next) => next ? next(null, 'bar') : 'bar',\n *   ([foo, bar], next) => next ? next(null, foo + bar) : foo + bar\n * )\n *\n * // sync\n * const state = process(['foo'])\n * console.log(state) // ['foo', 'bar', 'foobar']\n *\n * // async\n * process(['bar'], (err, result) => console.log(result)) // ['foo', 'bar', 'foobar']\n *\n */\n\n\nconst asyncify = (...fns) => {\n  return (initialState, done) => {\n    if (typeof initialState === 'function') {\n      done = initialState;\n      initialState = [];\n    }\n\n    const state = initialState || [];\n    let cursor = state.length;\n    let i = 0;\n\n    if (!Array.isArray(state)) {\n      throw new Error('asyncify: initialState must be an array');\n    }\n\n    if (!fns.length) {\n      throw new Error('asyncify: no functions detected');\n    }\n\n    if (typeof state[state.length - 1] === 'function') {\n      done = state.pop();\n      cursor = state.length;\n    }\n\n    const error = () => {\n      return new Error('asyncify: arguments must be functions');\n    };\n\n    if (!done) {\n      for (; i < fns.length; i++) {\n        if (typeof fns[i] !== 'function') {\n          throw error();\n        }\n\n        state[cursor + i] = fns[i](state);\n      }\n    } else {\n      /**\n       *\n       * @param {Error} [err]\n       * @param {any} [result]\n       */\n      const next = (err, result) => {\n        if (err) {\n          done(err);\n        } else {\n          state[cursor + i++] = result;\n\n          if (i < fns.length) {\n            if (typeof fns[i] !== 'function') {\n              done(error());\n            } else {\n              fns[i](state, next);\n            }\n          } else {\n            done(null, state[state.length - 1]);\n          }\n        }\n      };\n\n      fns[i](state, next);\n    }\n\n    return state;\n  };\n};\n\nconst cacheWrap = (read, cache) => {\n  const readFromCache = filename => {\n    if (!cache[filename]) {\n      cache[filename] = read(filename);\n    }\n\n    return cache[filename];\n  };\n\n  const readFromCacheAsync = (filename, done) => {\n    if (!cache[filename]) {\n      return read(filename, (err, content) => {\n        if (err) done(err);\n        done(err, cache[filename] = content);\n      });\n    }\n\n    return process.nextTick(() => {\n      done(null, cache[filename]);\n    });\n  };\n\n  return mix(readFromCache, readFromCacheAsync);\n};\n\nconst parseFiles = files => {\n  // resolve all files such that they match\n  // all of the paths glslify handles, which are otherwise\n  // absolute\n  return Object.keys(files).reduce((newCache, file) => {\n    newCache[path.resolve(file)] = files[file];\n    return newCache;\n  }, {});\n};\n\nmodule.exports = {\n  getTransformsFromPkg,\n  getImportName,\n  extractPreprocessors,\n  genInlineName,\n  cacheWrap,\n  mix,\n  parseFiles,\n  asyncify\n};","const createCacheBackend = (check, fallback, creator) => check() ? creator : fallback;\n\nconst createMemoryCache = () => {\n  const cache = {};\n  return {\n    set: (key, value) => {\n      cache[key] = value;\n    },\n    get: key => cache[key],\n    remove: key => {\n      delete cache[key];\n    },\n    clear: () => Object.keys(cache).forEach(key => {\n      delete cache[key];\n    })\n  };\n};\n\nconst createLocalStorageCache = createCacheBackend(() => global.localStorage, createMemoryCache, opts => {\n  const {\n    prefix = \"\"\n  } = { ...opts\n  };\n  const cache = global.localStorage;\n  return {\n    set: (key, value) => {\n      cache.setItem(`${prefix}${key}`, value);\n    },\n    get: key => cache.getItem(`${prefix}${key}`),\n    remove: key => {\n      cache.removeItem(`${prefix}${key}`);\n    },\n    clear: () => {\n      cache.clear();\n    }\n  };\n});\nexport const wrapCache = (async, sync = async.sync) => {\n  console.log(\"wrapCache\");\n  return cache => {\n    const _cache = cache || createLocalStorageCache();\n\n    return (key, ...args) => {\n      let done;\n\n      const cached = _cache.get(key);\n\n      if (typeof args[args.length - 1] === \"function\") {\n        done = args.pop();\n      }\n\n      if (cached) {\n        if (!done) {\n          return cached;\n        }\n\n        process.nextTick(() => done(null, cached));\n      } else {\n        if (!done) {\n          const result = sync(key, ...args);\n\n          _cache.set(key, result);\n\n          return result;\n        }\n\n        async(key, ...args, (err, result) => {\n          if (err) return done(err);\n\n          _cache.set(key, result, done);\n        });\n      }\n    };\n  };\n};","import get from \"./get\";\nexport const urlJoin = (...args) => args.join(\"/\").replace(/\\/+/, \"/\");\nconst defaultExts = [\".glsl\", \".vert\", \".frag\", \".geom\", \".vs\", \".fs\", \".gs\", \".vsh\", \".fsh\", \".gsh\", \".vshader\", \".fshader\", \".gshader\"];\n\nconst formatUrl = (base, ...args) => new URL(args.join(\"/\").replace(/\\/+/, \"/\"), base);\n\nconst matchExt = (pkgName, exts) => new RegExp(`(${exts.join(\"|\")})$`).test(pkgName);\n\nconst parseOptions = opts => ({\n  url: \"https://unpkg.com/\",\n  // url: \"https://cdn.jsdelivr.net/npm/\",\n  get: get,\n  exts: defaultExts,\n  type: \"HEAD\",\n  ...opts\n});\n\nconst resolve = (pkgName, opts, done) => {\n  const {\n    url,\n    get,\n    exts,\n    type\n  } = parseOptions(opts);\n  let i = 0 - matchExt(pkgName, exts);\n\n  const next = () => {\n    if (i < exts.length) {\n      const urlPath = formatUrl(url, pkgName + (exts[i++] || \"\")) + \"\";\n      get(urlPath, {\n        type\n      }, err => {\n        if (err && /^404/.test(err.message)) {\n          next();\n        } else {\n          done(null, urlPath);\n        }\n      });\n    } else {\n      done(new Error(`${pkgName} Not found`));\n    }\n  };\n\n  next();\n};\n\nresolve.sync = (pkgName, opts) => {\n  const {\n    url,\n    get,\n    exts,\n    type\n  } = parseOptions(opts);\n  let i = 0 - matchExt(pkgName, exts);\n\n  do {\n    try {\n      const urlPath = formatUrl(url, pkgName + (exts[i++] || \"\")) + \"\";\n      get(urlPath, {\n        type\n      });\n      return urlPath;\n    } catch (err) {\n      if (!/^404/.test(err.message)) {\n        throw new Error(`${pkgName} Not found`);\n      }\n    }\n  } while (i < exts.length);\n};\n\nexport default resolve;\nexport const sync = resolve.sync;\nexport const createCachedResolver = (cache = {}) => {\n  return (pkgName, opts, done) => {\n    if (cache[pkgName]) {\n      if (!done) {\n        return cache[pkgName];\n      }\n\n      done(null, cache[pkgName]);\n    }\n\n    if (!done) {\n      cache[pkgName] = resolve(pkgName, opts);\n      return cache[pkgName];\n    }\n\n    resolve(pkgName, opts, (err, resolved) => {\n      if (err) return done(err);\n      cache[pkgName] = resolved;\n      done(null, resolved);\n    });\n  };\n};\n/**\n * TODO LIST\n * - Check firts package.json to determine if the pacakge exists\n * - Cache with compression lmza https://github.com/LZMA-JS/LZMA-JS\n */","/* eslint-disable */\nimport Depper from '../../../../glslify-deps/depper';\nimport { wrapCache } from './utils';\nimport glslResolve from './glsl-resolve-browser';\nimport get from './get';\n\nclass DepperBrowser extends Depper {\n  constructor(opts) {\n    super({ ...opts,\n      async: true,\n      readFile: wrapCache(get)(),\n      resolve: wrapCache(glslResolve)(),\n      transformRequire: (filename, done) => {\n        console.log('transformRequire', filename, done);\n      }\n    });\n  }\n\n  inline(source, done) {\n    this._deps = [];\n    this._i = 0;\n    return super.inline(source, null, done);\n  }\n\n  getTransformsForFile(filename, done) {\n    console.log(filename); // this.readFile('')\n\n    done(null, []);\n    return [];\n  }\n\n}\n\nconst depper = opts => {\n  return new DepperBrowser(opts);\n};\n\nexport default depper;","import glslifyDeps from \"./glslify-deps\";\n\nconst glslifyBundle = require(\"glslify-bundle\");\n\nconst glslify = opts => {\n  const depper = glslifyDeps(opts);\n  return (source, cb) => {\n    depper.inline(source, (err, deps) => {\n      if (err) return cb(err);\n      cb(null, String(glslifyBundle(deps)));\n    });\n  };\n};\n\nexport default glslify;","import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useRef, useEffect, useLayoutEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport setup from \"./setup\";\n\nconst GlslSandbox = ({\n  className,\n  value,\n  onError\n}) => {\n  const [error, setError] = useState();\n  const canvasRef = useRef(null);\n  const drawRef = useRef(null);\n  useLayoutEffect(() => {\n    if (canvasRef.current) {\n      drawRef.current = setup(canvasRef.current, {\n        onError: err => {\n          if (onError) {\n            onError(onError);\n          }\n\n          setError(err);\n        }\n      });\n    }\n  }, [canvasRef, onError]);\n  useLayoutEffect(() => {\n    if (drawRef.current) {\n      return drawRef.current(value);\n    }\n  }, [drawRef, value]);\n  useLayoutEffect(() => {\n    if (error) {\n      setError(null);\n    }\n  }, [value]);\n  return /*#__PURE__*/_jsxs(\"div\", {\n    className: className,\n    children: [error && /*#__PURE__*/_jsx(\"div\", {\n      className: \"error-overlay\",\n      children: /*#__PURE__*/_jsx(\"pre\", {\n        children: /*#__PURE__*/_jsx(\"code\", {\n          children: error.message\n        })\n      })\n    }), /*#__PURE__*/_jsx(\"canvas\", {\n      ref: canvasRef\n    })]\n  });\n};\n\nexport default styled(GlslSandbox).withConfig({\n  displayName: \"glsl\",\n  componentId: \"vb91tm-0\"\n})([\"width:100%;height:100%;position:relative;overflow:auto;& .error-overlay{background-color:rgba(255,255,255,0.8);position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;}\"]);"],"sourceRoot":""}